#6.2散列分治
1.<<寻找 Top IP>>
    <1>.分而治之/hash映射
    首先把这一天访问百度日志的所有IP提取出来，然后逐个写入到一个大文件中，接着采用映射的方法，比如 Hash(IP)%1000，把整个大文件映射为1000个小文件。
    <2>.hash_map统计
    当大文件转化成了小文件，那么我们便可以采用hash_map(ip, value)来分别对1000个小文件中的IP进行频率统计，再找出每个小文件中出现频率最大的IP。
    <3>.堆/快速排序
    统计出1000个频率最大的IP后，依据各自频率的大小进行排序(可采取堆排序)，找出那个频率最大的IP，即为所求。

2.<<寻找热门查询Query>>
    由上面第1题，我们知道，数据大则划为小的，例如一亿个ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hash_map统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结果。但对于本题，数据规模比较小，能一次性装入内存。
    <1>.hash_map统计
    先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的hash_map，即hash_map(Query, Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并将Value值设为1；如果该字串在Table中，那么将该字串的计数加1 即可。最终我们在O(N)的时间复杂度内用hash_map完成了统计；
    <2>.堆排序
    借助堆这个数据结构，找出Top K，时间复杂度为O(N’*logK)。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O(n) + N' * O(logk），其中，N为1000万，N’为300万。

3.<<频数最高的100个词>>
    有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词
    1.分而治之/hash映射
    顺序读取文件，对于每个词x，取hash(x)%5000，然后把该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。当然，如果其中有的小文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
    2.hash_map统计
    对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。
    3.堆/归并排序
    取出出现频率最大的100个词(可以用含100个结点的最小堆)后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并(类似于归并排序)的过程了。
4.<<Query频度排序>>
    有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序.
    <1>.hash映射
    顺序读取10个文件，按照Hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
    <2>.hash_map统计
    找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query, query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。
    <3>.堆/快速/归并排序
    利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。

5.<<Join操作>>
          给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
    <1>.分而治之/Hash映射
    遍历文件a，对每个url求取Hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0a1a2...a999)中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中(记为b0b1...b999)。这样处理后，所有可能相同的url都在对应的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
    <2>.hash_set统计
    求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

#6.3多层划分
6.<<去重 | 寻找不重复的数字>>
    在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
    解法一：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。
    解法二：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。

7.<<中位数>>
    5亿个int找它们的中位数
   分析：首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。
     实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。解法二：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”

#6.6位图
8.<<快速查询>>
    给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
    解法一：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

    private int BYTESIZE = 8;
    void SetBit(char[] p, int n)
    {
        int i;
        for (i = 0; i < (n / BYTESIZE);)
            i++;
        // System.out.println(n + "  " + i);
        p[i] = (char) (p[i] | (1 << (n % BYTESIZE)));// 将该Bit位赋值1
    }

    void BitMapSort(int[] num)
    {
        // 为了简单起见，我们不考虑负数
        // BufferLen这个值是根据待排序的数据中最大值确定的
        // 待排序中的最大值是14，因此只需要2个Bytes(16个Bit)就可以了。
        int maxNum = getArrayMax(num);
        int bufferLen = maxNum / 8 + 1;
        // System.out.println(maxNum + "   " + bufferLen);
        char[] pBuffer = new char[bufferLen];

        // 要将所有的Bit位置为0，否则结果不可预知。
        // memset(pBuffer,0,BufferLen);

        for (int i = 0; i < num.length; i++)
            // 首先将相应Bit位上置为1
            SetBit(pBuffer, num[i]);

        // 输出排序结果
        for (int i = 0; i < bufferLen; i++)// 每次处理一个字节(Byte)
        {
            for (int j = 0; j < BYTESIZE; j++)// 处理该字节中的每个Bit位
            {
                // 判断该位上是否是1，进行输出，这里的判断比较笨。
                // 首先得到该第j位的掩码（0x01<<j），将内存区中的位和此掩码作与操作。最后判断掩码是否和处理后的 结果相同
                if ((pBuffer[i] & (1 << j)) == (1 << j))
                    System.out.printf("%d ", i * BYTESIZE + j);
            }
        }
    }

    private int getArrayMax(int[] num)
    {
        int maxNum = num[0];
        for (int i = 1; i < num.length; i++)
            if (num[i] > maxNum)
                maxNum = num[i];
        return maxNum;
    }

#Trie树(单词查找树)

Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。
Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

它有3个基本性质：
<1>根节点不包含字符，除根节点外每一个节点都只包含一个字符。
<2>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
<3>每个节点的所有子节点包含的字符都不相同。

问题实例
    1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析
    提示：用trie树统计每个词出现的次数，时间复杂度是O(n*L)（L表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是O(n*log(10))。所以总的时间复杂度，是O(n*L)与O(n*log(10))中较大的哪一个。

    2、寻找热门查询
    原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复的，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。
提示：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。





